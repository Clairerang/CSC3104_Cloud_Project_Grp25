<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Testing Notification â€” Daily Login</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body { font-family: Arial, Helvetica, sans-serif; padding: 24px; }
      .card { max-width: 480px; margin: 24px auto; padding: 18px; border: 1px solid #ddd; border-radius: 8px; }
      button { padding: 12px 18px; font-size: 16px; }
      input { padding: 8px; font-size: 14px; margin-bottom: 8px; width:100%; }
      .log { margin-top:12px; background:#f7f7f7; padding:10px; height:140px; overflow:auto; font-family:monospace; }
      /* Modal styles */
      .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.4); align-items: center; justify-content: center; z-index: 1000; }
      .modal { background: #fff; padding: 18px; border-radius: 8px; max-width: 420px; width: calc(100% - 40px); box-shadow: 0 8px 30px rgba(0,0,0,0.2); }
      .modal h3 { margin-top: 0; }
      .modal .actions { text-align: right; margin-top: 12px; }
      .modal button { padding: 8px 12px; }
      .modal .success { color: #086; }
      .modal .error { color: #c22; }
    </style>
  </head>
  <body>
    <div class="card">
      <h2>Daily "I'm Okay" Check-In</h2>
      <p>Simple test frontend to trigger a check-in event. This page posts to the backend `/checkin` endpoint which persists the check-in and publishes a notification event.</p>

      <label>userId</label>
      <input id="userId" placeholder="e.g. senior-1" />
      <label>name (optional)</label>
      <input id="name" placeholder="e.g. Alice" />
      <label>mood (optional)</label>
      <input id="mood" placeholder="e.g. okay" />
  <label>family email (optional)</label>
  <input id="familyEmail" placeholder="e.g. cloudproject6769@gmail.com" />
  <label>family phone (optional, E.164)</label>
  <input id="familyPhone" placeholder="e.g. +61412345678" />
  <label>device token (optional)</label>
  <input id="deviceToken" placeholder="paste FCM device token here" />

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
  <button id="dailyLogin" style="background:#2b8aef;color:#fff">Daily Login</button>
  <button id="saveUser">Register User</button>
  <button id="checkin">Do Daily Check-In</button>
      <button id="saveDevice" style="background:#3b7;color:#fff">Save Device Token</button>
      <button id="sendSms" style="background:#6b3;color:#fff">Send SMS</button>
      </div>

      <div class="log" id="log"></div>
    </div>

    <!-- Phone Verification Section -->
    <div class="card">
      <h2>ðŸ“± Phone Verification (OTP)</h2>
      <p>Test Twilio Verify service for OTP verification</p>

      <label>Phone Number (E.164 format, e.g. +61412345678)</label>
      <input id="verifyPhone" placeholder="+61412345678" />

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
        <button id="sendOtp" style="background:#9c27b0;color:#fff">Send OTP</button>
        <button id="checkOtp" style="background:#673ab7;color:#fff" disabled>Verify Code</button>
      </div>

      <div id="otpInputSection" style="display:none;margin-top:12px;">
        <label>Enter Verification Code</label>
        <input id="otpCode" placeholder="Enter 6-digit code" maxlength="6" pattern="[0-9]*" />
      </div>

      <div class="log" id="verifyLog"></div>
    </div>

    <!-- Confirmation modal shown after Daily Login -->
    <div id="confirmModalOverlay" class="modal-overlay" role="dialog" aria-modal="true" aria-hidden="true">
      <div class="modal" role="document">
        <h3 id="confirmTitle">Status</h3>
        <div id="confirmMessage">...</div>
        <div class="actions">
          <button id="confirmClose">Close</button>
        </div>
      </div>
    </div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script>
      // Lightweight behavior without bundling â€” simple DOM usage
      const logEl = document.getElementById('log');
      function log(msg){ logEl.innerText = new Date().toLocaleTimeString() + ' - ' + msg + '\n' + logEl.innerText }

      // Verify log
      const verifyLogEl = document.getElementById('verifyLog');
      function verifyLog(msg){ verifyLogEl.innerText = new Date().toLocaleTimeString() + ' - ' + msg + '\n' + verifyLogEl.innerText }

      // Firebase Web Push: auto-register service worker and request token
      async function enableWebPush() {
        try {
          // feature detection: service worker and Notification API
          log('UA: ' + navigator.userAgent);
          if (!('serviceWorker' in navigator)) {
            log('enableWebPush error: Service Workers not supported in this browser');
            return;
          }
          if (typeof Notification === 'undefined') {
            log('enableWebPush error: Notifications API is not available in this browser');
            return;
          }
          const cfgRes = await fetch('/fcm/config');
          if (!cfgRes.ok) { log('FCM config not available: ' + cfgRes.status); return; }
          const cfg = await cfgRes.json();
          // load firebase scripts (compat) dynamically â€” try local vendor first, fallback to CDN
          const vendorBase = '/testing-notification/vendor/';
          async function loadVendorOrCdn(fileName, cdnUrl) {
            const localUrl = vendorBase + fileName;
            try {
              const r = await fetch(localUrl, { method: 'HEAD' });
              if (r.ok) return await loadScript(localUrl);
            } catch (e) {}
            return await loadScript(cdnUrl);
          }
          // Avoid loading firebase-app twice in the page global scope. Some browsers
          // or service-worker flows can cause the compat bundle to appear already
          // defined; skip loading the app bundle if `firebase` exists.
          if (typeof window.firebase === 'undefined') {
            await loadVendorOrCdn('firebase-app-compat.js', 'https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js');
          } else {
            log('firebase already present in page, skipping firebase-app load');
          }
          // Always load messaging compat (it expects firebase to be available)
          await loadVendorOrCdn('firebase-messaging-compat.js', 'https://www.gstatic.com/firebasejs/9.22.1/firebase-messaging-compat.js');

          // register service worker scoped to /testing-notification
          const swUrl = '/testing-notification/firebase-messaging-sw.js';
          const reg = await navigator.serviceWorker.register(swUrl, { scope: '/testing-notification/' });
          log('Service worker registered');

          // init firebase app
          firebase.initializeApp({
            apiKey: cfg.apiKey,
            authDomain: cfg.authDomain,
            projectId: cfg.projectId,
            messagingSenderId: cfg.messagingSenderId,
            appId: cfg.appId
          });

          const messaging = firebase.messaging();

          // request permission
          // some browsers expose Notification but calling requestPermission may throw â€” guard it
          let p = Notification.permission;
          try {
            if (p !== 'granted') p = await Notification.requestPermission();
          } catch (permErr) {
            log('enableWebPush error requesting permission: ' + (permErr && permErr.message ? permErr.message : permErr));
            return;
          }
          if (p !== 'granted') { log('Notification permission not granted'); return; }

          const token = await messaging.getToken({ vapidKey: cfg.vapidKey, serviceWorkerRegistration: reg });
          if (token) {
            log('Obtained FCM token: ' + token.slice(0,20) + '...');
            // save token to backend
            const userId = document.getElementById('userId').value.trim() || localStorage.getItem('testing_userId');
            if (userId) {
              await fetch('/save-device-token', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId, token, platform: 'web' }) });
              log('Saved token for user ' + userId);
              document.getElementById('deviceToken').value = token;
            }
          } else {
            log('No token received (maybe permission denied)');
          }
        } catch (e) { log('enableWebPush error: ' + (e && e.message ? e.message : e)); }
      }

      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script'); s.src = src; s.onload = resolve; s.onerror = reject; document.head.appendChild(s);
        });
      }

      // Attempt to enable Web Push automatically on page load.
      // Note: Many browsers require a user gesture to show the permission prompt.
      // If automatic registration is blocked, we'll show a manual fallback button.
      function showManualEnable() {
        if (document.getElementById('manualEnable')) return;
        const btn = document.createElement('button');
        btn.id = 'manualEnable';
        btn.textContent = 'Enable Web Push';
        btn.style.background = '#ff8a00'; btn.style.color = '#fff'; btn.style.padding = '8px'; btn.style.marginLeft = '8px';
        btn.onclick = enableWebPush;
        document.querySelector('.card > div').appendChild(btn);
        log('Automatic registration not allowed by browser; please tap "Enable Web Push"');
      }

      async function tryAutoRegister() {
        // small delay so page UI is interactive
        await new Promise(r => setTimeout(r, 400));
        log('Attempting automatic Web Push registration...');
        try {
          await enableWebPush();
          // if permission still not granted, show manual enable
          if (typeof Notification !== 'undefined' && Notification.permission !== 'granted') {
            showManualEnable();
          }
        } catch (e) {
          log('Auto-register error: ' + (e && e.message ? e.message : e));
          showManualEnable();
        }
      }

      // Start automatic attempt when page is ready
      window.addEventListener('load', () => tryAutoRegister());

      document.getElementById('saveUser').addEventListener('click', async () => {
        const userId = document.getElementById('userId').value.trim();
        const name = document.getElementById('name').value.trim();
        if (!userId) return alert('please provide userId');
        try{
          const res = await fetch('/register-user', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId, name }) });
          const j = await res.json();
          log('register-user -> ' + JSON.stringify(j));
          if (j && j.user && j.user.userId) {
            localStorage.setItem('testing_userId', j.user.userId);
            log('Saved userId to localStorage: ' + j.user.userId);
          }
        }catch(e){ log('register-user error: ' + e.message) }
      });

      document.getElementById('checkin').addEventListener('click', doCheckin);

      // Single-click daily login: registers the user (if needed) then performs checkin
      document.getElementById('dailyLogin').addEventListener('click', async () => {
        let userId = document.getElementById('userId').value.trim() || localStorage.getItem('testing_userId');
        const name = document.getElementById('name').value.trim();
        const mood = document.getElementById('mood').value.trim() || 'okay';
        const familyEmail = document.getElementById('familyEmail').value.trim();
        if (!userId) return alert('please provide a userId or register first');

        // ensure user exists
        try {
          const resUser = await fetch('/register-user', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId, name }) });
          const ju = await resUser.json();
          log('register-user -> ' + JSON.stringify(ju));
          if (ju && ju.user && ju.user.userId) {
            localStorage.setItem('testing_userId', ju.user.userId);
            document.getElementById('userId').value = ju.user.userId;
            userId = ju.user.userId;
          }
        } catch (e) { log('register-user error: ' + e.message); }

        // trigger daily login endpoint which will publish a daily_login event (used by email-service)
        try {
          const familyPhone = document.getElementById('familyPhone').value.trim();
          const payload = { userId, mood, userName: name, familyEmail, familyPhone };
          const res = await fetch('/daily-login', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          const j = await res.json();
          log('daily-login -> ' + JSON.stringify(j));

          // Show confirmation modal â€” note: delivery is asynchronous. This confirms the request
          // to send an email and/or SMS has been published to the backend.
          const toEmail = familyEmail || (j && j.publishedEvent && j.publishedEvent.familyEmail) || 'configured recipient';
          const toPhone = familyPhone || (j && j.smsPublishedEvent && j.smsPublishedEvent.to) || null;
          const phoneMsg = toPhone ? ` An SMS will be sent to: ${toPhone}` : '';
          showModal(`Daily login published. An email will be sent to: ${toEmail}.${phoneMsg}`, /*isError=*/false);
        } catch (e) {
          log('daily-login error: ' + e.message);
          showModal('Failed to trigger daily login: ' + (e && e.message ? e.message : String(e)), /*isError=*/true);
        }
      });

        // Send SMS button: publishes sms event via notification-service
        document.getElementById('sendSms').addEventListener('click', async () => {
          const to = document.getElementById('familyPhone').value.trim();
          const name = document.getElementById('name').value.trim();
          if (!to) return alert('please provide a phone number in E.164 format');
          const body = `${name ? name + ' checked in: ' : 'Daily login: '}This is a test SMS from the notification PoC.`;
          try {
            const res = await fetch('/send-sms', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ to, body, userId: document.getElementById('userId').value.trim() }) });
            const j = await res.json();
            log('send-sms -> ' + JSON.stringify(j));
            if (j && j.ok) showModal(`SMS publish requested for ${to}`, false);
            else showModal('SMS publish failed: ' + (j && j.error ? j.error : 'unknown'), true);
          } catch (err) {
            log('send-sms error: ' + err.message);
            showModal('Failed to request SMS: ' + (err && err.message ? err.message : String(err)), true);
          }
        });

      async function doCheckin() {
        let userId = document.getElementById('userId').value.trim() || localStorage.getItem('testing_userId');
        const mood = document.getElementById('mood').value.trim() || 'okay';
        if (!userId) return alert('please set or register a userId first');
        const payload = { userId, mood };
        try{
          const res = await fetch('/checkin', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          const j = await res.json();
          log('checkin -> ' + JSON.stringify(j));
        }catch(e){ log('checkin error: ' + e.message) }
      }

      // Save device token (manual paste) to backend for FCM testing
      document.getElementById('saveDevice').addEventListener('click', async () => {
        const userId = document.getElementById('userId').value.trim() || localStorage.getItem('testing_userId');
        const token = document.getElementById('deviceToken').value.trim();
        if (!userId || !token) return alert('provide userId and token');
        try {
          const res = await fetch('/save-device-token', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ userId, token, platform: 'web' }) });
          const j = await res.json();
          log('save-device -> ' + JSON.stringify(j));
        } catch (e) { log('save-device error: ' + e.message) }
      });

      // prefill from localStorage
      const stored = localStorage.getItem('testing_userId');
      if (stored) document.getElementById('userId').value = stored;

      // Phone Verification Logic
      let currentVerificationPhone = null;

      document.getElementById('sendOtp').addEventListener('click', async () => {
        const phone = document.getElementById('verifyPhone').value.trim();
        if (!phone) {
          verifyLog('âŒ Please enter a phone number');
          return alert('Please enter a phone number in E.164 format (e.g. +61412345678)');
        }
        if (!phone.startsWith('+')) {
          verifyLog('âŒ Phone must be in E.164 format (start with +)');
          return alert('Phone must be in E.164 format (start with +)');
        }

        try {
          verifyLog(`ðŸ“¤ Sending verification code to ${phone}...`);
          const res = await fetch('http://localhost:4004/verify/send', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ to: phone, channel: 'sms' })
          });
          const j = await res.json();
          verifyLog(`âœ… Response: ${JSON.stringify(j)}`);

          if (j && j.ok && j.status === 'pending') {
            currentVerificationPhone = phone;
            document.getElementById('otpInputSection').style.display = 'block';
            document.getElementById('checkOtp').disabled = false;
            document.getElementById('otpCode').value = '';
            document.getElementById('otpCode').focus();
            showModal(`âœ… Verification code sent to ${phone}!\n\nCheck your SMS and enter the 6-digit code below.`, false);
            verifyLog(`âœ… Code sent! Status: ${j.status}`);
          } else {
            verifyLog(`âŒ Failed: ${JSON.stringify(j)}`);
            showModal('Failed to send verification code: ' + (j && j.error ? j.error : JSON.stringify(j)), true);
          }
        } catch (err) {
          verifyLog(`âŒ Error: ${err.message}`);
          showModal('Error sending verification code: ' + (err && err.message ? err.message : String(err)), true);
        }
      });

      document.getElementById('checkOtp').addEventListener('click', async () => {
        const code = document.getElementById('otpCode').value.trim();
        if (!code) {
          verifyLog('âŒ Please enter the verification code');
          return alert('Please enter the verification code from your SMS');
        }
        if (!currentVerificationPhone) {
          verifyLog('âŒ No active verification session');
          return alert('Please send a verification code first');
        }

        try {
          verifyLog(`ðŸ” Verifying code ${code} for ${currentVerificationPhone}...`);
          const res = await fetch('http://localhost:4004/verify/check', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ to: currentVerificationPhone, code })
          });
          const j = await res.json();
          verifyLog(`âœ… Response: ${JSON.stringify(j)}`);

          if (j && j.ok && j.verified) {
            verifyLog(`âœ…âœ…âœ… VERIFIED! Phone ${currentVerificationPhone} confirmed`);
            showModal(`ðŸŽ‰ SUCCESS!\n\nPhone number ${currentVerificationPhone} has been verified!`, false);
            // Optionally auto-fill family phone field
            document.getElementById('familyPhone').value = currentVerificationPhone;
            // Reset state
            document.getElementById('otpInputSection').style.display = 'none';
            document.getElementById('checkOtp').disabled = true;
            currentVerificationPhone = null;
          } else if (j && !j.verified) {
            verifyLog(`âŒ Verification failed - incorrect code or expired`);
            showModal('âŒ Verification failed!\n\nThe code is incorrect or has expired. Please try again.', true);
          } else {
            verifyLog(`âŒ Failed: ${JSON.stringify(j)}`);
            showModal('Verification failed: ' + (j && j.error ? j.error : JSON.stringify(j)), true);
          }
        } catch (err) {
          verifyLog(`âŒ Error: ${err.message}`);
          showModal('Error verifying code: ' + (err && err.message ? err.message : String(err)), true);
        }
      });

      // Allow Enter key to submit OTP code
      document.getElementById('otpCode').addEventListener('keypress', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          document.getElementById('checkOtp').click();
        }
      });

      // Modal helpers
      const modalOverlay = document.getElementById('confirmModalOverlay');
      const modalTitle = document.getElementById('confirmTitle');
      const modalMessage = document.getElementById('confirmMessage');
      const modalClose = document.getElementById('confirmClose');

      function showModal(message, isError) {
        modalTitle.textContent = isError ? 'Error' : 'Success';
        modalMessage.textContent = message;
        modalMessage.className = isError ? 'error' : 'success';
        modalOverlay.style.display = 'flex';
        modalOverlay.setAttribute('aria-hidden', 'false');
        // focus close button for keyboard users
        setTimeout(() => modalClose.focus(), 50);
      }

      function closeModal() {
        modalOverlay.style.display = 'none';
        modalOverlay.setAttribute('aria-hidden', 'true');
      }

      modalClose.addEventListener('click', closeModal);
      // close when clicking outside modal content
      modalOverlay.addEventListener('click', (ev) => {
        if (ev.target === modalOverlay) closeModal();
      });
      // close on Escape
      window.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && modalOverlay.style.display === 'flex') closeModal();
      });
    </script>
  </body>
</html>
